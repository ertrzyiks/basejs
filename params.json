{"name":"Base.js","tagline":"NodeJS and browser javascript objective paradigm helper.","body":"Base.js\r\n======\r\n\r\nBase make it easier to write objective code in javascript for NodeJS and browsers.\r\n\r\n\r\nLibrary includes Backbone's inheritance code with improvements inspired by Sencha framework.\r\n\r\n* Backbone by Jeremy Ashkenas, DocumentCloud Inc. http://backbonejs.org/\r\n* Sencha Touch 2, Sencha Inc. http://www.sencha.com/products/touch\r\n\r\n\r\nScript expose object \r\n\r\n>Base\r\n\r\nwhich is parent for all defined classes. You can instantialize object of Base class as well.\r\n\r\n### Usage ###\r\n\r\n```javascript\r\n/**\r\n * @method extend\r\n * @static\r\n * @param protoProps {Object, Function} Prototype properties/methods \r\n *   or class from which to copy prototype\r\n * @param [staticProps] {Object} Static properties/methods\r\n * @return {Function} reference of defined class\r\n */\r\nBase.extend(protoProps, [staticsProps]);\r\n\r\n```\r\n\r\nEvery class can define custom `constructor` function, which will be called on object initialization.\r\n\r\nPrimitive properties can be set directly in props. \r\nObjects and arrays should be set in constructor or getter to avoid prototype-shared instances. \r\nOtherwise manipulation of such object/array will be applied to all objects of class.\r\n\r\nOverriding methods is supported with two helper functions. You can use them in any method of class.\r\n```javascript\r\n/**\r\n * Call current method from parent prototype/static context. \r\n * Two versions allow you to convenient use Function.apply() \r\n * or Function.call() way\r\n */\r\nthis.callParent( ... );\r\nthis.applyParent( params );\r\n\r\n```\r\n\r\n### Examples ###\r\n\r\n\r\n#### Simple ####\r\n```javascript\r\n//Extend Base to define custom class\r\nvar Vehicle = Base.extend({\r\n  hasEngine: false,\r\n  serialNumber: 10,\r\n  \r\n  //declaration\r\n  elements: null,\r\n  \r\n  constructor: function(){\r\n    //initialization\r\n    this.elements = [];\r\n  }\r\n});\r\n\r\n//and extend custom class\r\nvar Car = Vehicle.extend({\r\n  //override default vehicle property value\r\n  hasEngine: true\r\n});\r\n\r\nvar myCar = new Car();\r\n//myCar.hasEngine === true\r\n```\r\n\r\n#### Overriding methods with call to super ####\r\n```javascript\r\nvar Person = Base.extend({\r\n  name: \"\",\r\n  \r\n  //Capture initial parameter `name`\r\n  constructor: function( name ){\r\n    this.name = name;\r\n  },\r\n  \r\n  //Be polite and say hello\r\n  sayHello: function(){\r\n    this.say(\"Hello, my name is \" + this.name);\r\n  },\r\n  \r\n  //generic method to output data\r\n  say: function( message ){\r\n    console.log(message);\r\n  }\r\n});\r\n\r\nvar ShoutingPerson = Person.extend({\r\n  //Add expression to all you say :)\r\n  say: function(message){\r\n    this.callParent(message + \"!!!\");\r\n  }\r\n});\r\n\r\nvar me = new ShoutingPerson(\"John\");\r\n\r\nme.sayHello(); //console.log(\"Hello, my name is John!!!\")\r\n```\r\n\r\n#### Static properties ####\r\n```javascript\r\nvar Log = Base.extend({\r\n  //put prototype members here\r\n},\r\n{\r\n  //Statics\r\n  LEVEL_ERROR: 3,\r\n  LEVEL_WARN: 2,\r\n  LEVEL_INFO: 1\r\n  LEVEL_NONE: 0\r\n});\r\n\r\nconsole.log(Log.LEVEL_ERROR); // 3\r\n```\r\n\r\n\r\n### Interfaces ###\r\n\r\nAny class can be use as an interface. By adding `implement` call into your class definition chain you can enforce existence of members in next `extend` call.\r\n\r\n```javascript\r\nvar ITask = Base.extend({\r\n  execute: function(){}\r\n});\r\n\r\n\r\nvar DisplayInfo = Base\r\n  .implement( ITask )\r\n  .extend({\r\n    //Lack of this function would cause exception\r\n    execute: function(){\r\n      console.log(\"Hello world!\");\r\n    }\r\n  });\r\n```\r\n\r\nAny object created with Base or Base children class can be tested for being instance of class implementing a interface.\r\n\r\n```javascript\r\nif( (new DisplayInfo()).isImplementing( ITask ) )\r\n{\r\n\t//Put your code here\r\n}\r\n```\r\n\r\n\r\n### Mixins ###\r\nMixins are shared, reusable, prototyped and/or static classes. The `use` operation works just like `extend`, but uses class-function instead hashmaps `{}`.\r\n\r\n```javascript\r\nvar Mixin = Base.extend({\r\n  onClick: function(e){\r\n    console.log(\"Im shared on click handler, YAY!\");\r\n  }\r\n});\r\n\r\nvar Entry = Base.use(Mixin).extend({\r\n  constructor: function(){\r\n    this.bind(\"click\", this.onClick);\r\n  },\r\n  \r\n  \r\n  bind: function(event, cb){\r\n    //Do some binding\r\n  }\r\n});\r\n```\r\n\r\n\r\n```javascript\r\n//Copy prototype from Class1\r\nvar Class2a = Base.extend(Class1).extend({ ... });\r\n//Copy prototype and static members from Class1\r\nvar Class2b = Base.use(Class1).extend({ ... });\r\n```\r\n\r\n\r\n\r\n\r\n","google":"UA-46750927-1","note":"Don't delete this file! It's used internally to help with page regeneration."}